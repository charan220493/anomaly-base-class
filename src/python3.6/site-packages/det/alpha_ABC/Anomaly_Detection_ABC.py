from abc import ABCMeta, abstractmethod
from logging import getLogger as _getLogger
from pandas import read_csv as _read_csv, pivot_table as _pivot_table, DataFrame as _DataFrame, Series as _Series, date_range as _date_range, _libs as _pandaslibs
from numpy import nonzero as _nonzero, array as _array, float as _float, float64 as _float64, int64 as _int64, mean as _mean, random as _random, ones as _ones, sum as _sum, sqrt as _sqrt, arange as _arange, concatenate as _concatenate, apply_over_axes as _apply_over_axes, absolute as _absolute

logger = _getLogger(__name__)


class AlphaResultObject(object):
	"""Use this base class to define KPI's for result of an anaomaly detection algorithm
	@property 'metric_column_list' in the subclass should be overidden as a property"""

	PREDICTION = 'prediction'
	ERROR_COEFF = 'error_coeff'
	STATUS_CODE = 'status_code'
	SEVERITY = 'severity'
	IS_ANOMALY = 'is_anomaly'

	def __new__(cls, *args, **kwargs):
		instance = object.__new__(cls, *args, **kwargs)
		super_instance = object.__new__(AlphaResultObject, *args, **kwargs)
		#if cls is AlphaResultObject:
		#	raise TypeError('Subclass AlphaResultObject() as Base class AlphaResultObject() cannot be directly instantiated')

		if hasattr(instance, 'metric_column_list'):
			sub_metric_col_list = instance.__getattribute__('metric_column_list')
			super_metric_col_list = super_instance.__getattribute__('metric_column_list')
			if not set(super_metric_col_list).issubset(sub_metric_col_list):
				raise ValueError('Subclass metric_column_list attribute should contain all default elements of AlphaResultObject.metric_column_list')
		else:
			raise NotImplementedError('Method metric_column_list() is not implemented by subclass')
		return instance

	def __init__(self, prediction=-1, error_coeff=-1, status_code=-1, severity=-1, is_anomaly=False):
		self.prediction = prediction
		self.error_coeff = error_coeff
		self.status_code = status_code
		self.severity = severity
		self.is_anomaly = is_anomaly

	def get_result_dict(self):
		result_dict = dict()
		result_dict[self.PREDICTION] = self.prediction
		result_dict[self.ERROR_COEFF] = self.error_coeff
		result_dict[self.STATUS_CODE] = self.status_code
		result_dict[self.SEVERITY] = self.severity
		result_dict[self.IS_ANOMALY] = self.is_anomaly
		return result_dict

	@property
	def metric_column_list(self):
		"""Define metric column names which should be used as part of dataframe schema.
		The subclass should override the method as a @property"""
		return [self.PREDICTION, self.ERROR_COEFF, self.STATUS_CODE, self.SEVERITY, self.IS_ANOMALY]


class AlphaBaseClass(metaclass=ABCMeta):
	"""Subclass this ABC and implement abstract methods. This is to keep code readable and consistent across various
	Anomaly Detection algorithm/ Projects that will be implemented as part of Alpha"""

	@abstractmethod
	def __init__(self, data=None, value_columns=None, grouping_cols=None, time_column=None, default_threshold=3, threshold_dict=None):
		self.meta_data_dict = dict()
		self.ad_thresholds_aggregator = dict()
		self.data = data
		self.value_column = value_columns
		self.grouping_columns = grouping_cols
		self.time_column = time_column
		self.default_threshold = default_threshold
		self.set_AD_threshold_UDF(threshold_dict)

	def set_AD_threshold_UDF(self, *args, **kwargs):
		for value_col in self.value_column:
			if value_col in kwargs:
				self.ad_thresholds_aggregator[value_col] = kwargs[value_col]
			else:
				self.ad_thresholds_aggregator[value_col] = self.default_threshold

	def define_meta_data(self):
		# any meta information that is not in the meta engine which needs to be used when applying AD algorithm
		pass

	def transform(self, data, *args, **kwargs):

		pass

	@abstractmethod
	def apply_prediction(self, data=None, agg_col_name=None, **additional_params):

		pass

	def apply_vectorized_prediction(self, *args, **kwargs):

		pass

	def define_result_metric(self):
		"""Define a metrics as list of Strings which should be a superset of AlphaResultObject().metric_column_list"""

		return AlphaResultObject().metric_column_list

	def ad_processor(self, input_data, parameter_dict=None, agg_col_name=None, default_result=None):
		logger = _getLogger(__name__)
		
		nan_map = input_data.isnull()
		result = {}
		default_result['timestamp'] = input_data.index.max()
		_STATUS_CODE = AlphaResultObject.STATUS_CODE

		if nan_map.agg('sum') == 0:
			if input_data.shape[0] > 1:
				result = self.apply_prediction(data=input_data, agg_col_name=agg_col_name, param_dict=parameter_dict)
				if not isinstance(result, dict):
					raise TypeError('Return type of apply_prediction should be a dict() object')
				else:
					if set(result.keys()).issubset(AlphaResultObject().metric_column_list):
						raise ValueError('Result dictionary key set should contain all elements of AlphaResultObject().metric_column_list')
			else:
				result[_STATUS_CODE] = 2
		else:
			result[_STATUS_CODE] = 1

		result_dict = {**default_result, **result}

		return result_dict


class AlphaPreProcessor(object):

	def normalize_data(self, input_df, normalizing_col_str, normalizing_col_value, group_col_list, value_col_list):
		if not isinstance(normalizing_col_str, str):
			raise TypeError("normalizing_str_col argument should be of type string but found " + str(type(normalizing_col_str)))
		normalizing_df_pre = input_df[input_df[normalizing_col_str] == normalizing_col_value]
		nm_string = "_nm"
		nm_values_cols = []
		renamed_values_col = {}
		try:
			if isinstance(value_col_list, str):
				value_col_list = [value_col_list]
			normalizing_df = normalizing_df_pre[group_col_list + value_col_list]
			for val in value_col_list:
				renamed_col = val + nm_string
				nm_values_cols.append(renamed_col)
				renamed_values_col[val] = renamed_col
			normalizing_df.rename(columns=renamed_values_col, inplace=True)
			merged_df = input_df.merge(normalizing_df, how='inner', left_on=group_col_list, right_on=group_col_list)
			for val in value_col_list:
				merged_df[val] = merged_df[val] / merged_df[renamed_values_col[val]]
			return merged_df[input_df.columns]
		except Exception as e:
			logger.error("Exception in normalize_data:%s" % (e))
			raise (e)
